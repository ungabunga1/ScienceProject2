package model;


import main.GsonHandler;
import main.Randomizer;
import libraries.linearalgebra.Vector;

import java.io.IOException;
import java.lang.reflect.Array;
import java.util.*;

public class Set {
    // variables
    public static Set[] Sets;
    public static Set[] RandomSets;


    protected int[][] data; // data of the dataset. each row is an image. each row is split into 3 1024 sections that represent the red, green, and blue values of an image respectively
    protected Vector[] vectorData; // data but each image is a vector
    protected int[] labels; // labels for the data. the "correct answers"
    protected  Vector[] desired; // labels but in a vector form
    protected String[] labelNames; // what the labels actually mean

    public static void initSets() throws IOException {
        Sets = GsonHandler.loadSets();
        RandomSets = randomizeSets(Sets);
    }


    public Set(int[][] data, int[] labels, String[] labelNames) {
        this.data = data;
        this.labels = labels;
        this.labelNames = labelNames;


        this.init();
    }

    public Set(Set set) {
        this.data = set.getData();
        this.labels = set.getLabels();
        this.labelNames = set.getLabelNames();
        this.init();
    }

    private void generateVectorData() {
        var b = Arrays.stream(data).map(Vector::new).toArray(Vector[]::new);
        this.vectorData = b;
    }
    public Set init() { // ran when generated by gson object to populate the desired class
        desired = new Vector[labels.length]; // every value automatically set to 0

        for (int i = 0; i < labels.length; i++) { // loop through every label and create an array of doubles that represent the desired neuron output
            desired[i] = new Vector(new double[labelNames.length]);
            desired[i] = desired[i].set(labels[i], 1.0f);
        }
        generateVectorData();

        return this;
    }

    public static Set[] randomizeSets(Set[] sets) {
        Set[] randomSets = new Set[sets.length];

        for (int i = 0; i < randomSets.length-1; i++) {
            randomSets[i] = sets[i].randomizeSet();
        }
        randomSets[sets.length - 1] = new Set(sets[sets.length - 1]);


        return randomSets;
    }
    public Set randomizeSet() { // ony labels change

        List<Integer> randomLabels = new ArrayList<>(Arrays.stream(labels).boxed().toList());

        Collections.shuffle(randomLabels, Randomizer.rand);

        return new Set(data.clone(),randomLabels.stream().mapToInt(i->i).toArray(),labelNames.clone());
    }

    public static <T>T[][] randomlySplit(T[] orignalArray, int splits, long seed) {
        if (orignalArray.length % splits != 0) {
            throw new IllegalArgumentException(orignalArray.length +" Not Divisible By "+splits);
        }

        // bro... don't worry about it, it works, i swear
        int perSplit = orignalArray.length/splits;
        T[][] newVectors = (T[][]) Array.newInstance(orignalArray.getClass().getComponentType(), splits, perSplit);
        Random rand = new Random(seed);

        // shuffle the array before splitting
        List<T> vectorsList = Arrays.asList(orignalArray);
        Collections.shuffle(vectorsList,rand);
        T[] arr = (T[])vectorsList.toArray((T[]) Array.newInstance(orignalArray.getClass().getComponentType(), 0));

        for (int i = 0; i < splits; i++) {
            int from = i * perSplit; // inclusive
            int to = (i+1) * perSplit; // exclusive
            newVectors[i] = Arrays.copyOfRange(arr, from, to);

        }

        return newVectors;
    }

    public static <T>T[][] split(T[] orignalArray, int splits) {
        if (orignalArray.length % splits != 0) {
            throw new IllegalArgumentException(orignalArray.length +" Not Divisible By "+splits);
        }

        int perSplit = orignalArray.length/splits;
        T[][] newVectors = (T[][]) Array.newInstance(orignalArray.getClass().getComponentType(), splits, perSplit);

        for (int i = 0; i < splits; i++) {
            int from = i * perSplit; // inclusive
            int to = (i+1) * perSplit; // exclusive
            newVectors[i] = Arrays.copyOfRange(orignalArray, from, to);
        }

        return newVectors;
    }

    // getters and setters
    public int[][] getData() {
        return data.clone();
    }

    public void setData(int[][] data) {
        this.data = data;
    }

    public int[] getLabels() {
        return labels.clone();
    }

    public void setLabels(int[] labels) {
        this.labels = labels;
    }

    public Vector[] getDesired() {
        return desired.clone();
    }

    public void setDesired(Vector[] desired) {
        this.desired = desired;
    }

    public String[] getLabelNames() {
        return labelNames.clone();
    }

    public void setLabelNames(String[] labelNames) {
        this.labelNames = labelNames;
    }

    public Vector[] getVectorData() {
        return vectorData.clone();
    }

    public void setVectorData(Vector[] vectorData) {
        this.vectorData = vectorData;
    }

}
